学习笔记

* 【1-4】题均是简单题，[柠檬水找零]、[模拟行走机器人]只是模拟题；[买卖股票的最佳时机II]和[分发饼干]是简单贪心算法

* 使用二分查找，寻找一个半有序数组[4,5,6,7,0,1,2]中间无序的地方。

  <u>*讲道理，这题和 **寻找旋转排序数组中的最小值** 不是一样的嘛！*</u>

* 【单词接龙】——**构图，然后在图上找最短路径**

  构图，然后在图上找最短路径。

     * 构图方式
       将词典中的每两个单词进行比对，如果满足转换条件，则在这两个单词之间连上线。
  * 在构建好的图上进行BFS
    `cost[]` 表示每个单词到 `beginWord` 的最短路径，除了 `cost[beginWord]` 初始化为 `1`【因为长度包括 `beginWord` 本身】，其他值初始化为 `INT_MAX`。
    最后返回 `cost[dest]` 即可。

* 【岛屿数量】——**使用 `BFS` 和 `DFS` 找连通域**

  通过一次 `dfs` 或者 `bfs` 找到一个连通域，然后数连通域的数量即可。

* 【跳跃游戏】——**贪心算法**

  持续更新变量 `MAXX`，其表示当前能跳的最远位置。
  当遍历到某个位置 `i` 时，如果 `i>MAXX`，则表示从 `i` 这个地方断掉了，所以无法跳到最后位置，直接返回 `false` 即可。

* 【搜索旋转排序数组】——**二分搜索**

  根据旋转数组的特性，当元素不重复时，如果 `nums[i]<=nums[j]`，说明区间 `[i,j]` 是连续递增的。

* 【搜索二维矩阵】——**二分搜索**

  从左上角或者右下角的元素开始搜索。
  为什么可以从这两个元素开始呢？
  以右下角的元素为例，它向上走，元素大小递减，它向右走，元素大小递增，两个方向具有相反的单调性。左上角同理。

* 【寻找旋转排序数组中的最小值】——**二分搜索**

  通过分析 **中值** 和 **右值** 的大小关系
  1） 中 值 > 右 值，则说明目标值在右半边；
  2）中 值 < 右 值，则说明目标值在左半边；

* 【单词接龙II】

  本题和 [Leetcode 127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/) 的区别是：需要打印单词转换过程。
  为了能够打印，本题较 `Leetcode 127` 做出如下改变： **队列中的每个节点中保存的是从起点开始的所有路径**。

  对于每次取出的节点 `now`，每个节点都是一个数组，数组中的最后一个元素为当前路径的最后节点 `last`:

  * 若该节点为终点，则将其路径转换为对应的单词存入答案；【这里不需要进行路径长度检查，因为 `BFS` 本来就是一步得到最短路径，而不像 `DFS` 那样迭代得到最短距离】
  * 若该节点不为终点，则遍历和它连通的节点（假设为 `to`）中满足 `cost[to]>=cost[now]+1` 的加入队列，并更新 `cost[to]=cost[last]+1`。如果 `cost[to]<cost[now]+1`，说明这个节点已经被访问过，不需要再考虑。

* 【跳跃游戏II】——**贪心算法**

  维持一个变量 `MAXX` 来记录当前位置所能跳的最远距离，并不是每一次更新最远跳跃距离实际上是要跳的。例如在位置`0`，我们能到达的最远距离是 `0+nums[0]`，但是在到达 `0+nums[0]`前我们会多次更新最远跳，而我们不知道哪个位置是实现最少跳跃的局部位置。

  实际上，我们只需要知道一点：**在到达位置`0+nums[0]`后，我们必然需要再跳一次，这样我们才能继续前进。** 所以我们另外维持一个变量`pos`，它记录的是在我们在执行跳跃动作时能到达的最远位置，即为当前时刻的 `MAXX`。每当我们到达边界时，跳跃步数加1，更新边界。



































